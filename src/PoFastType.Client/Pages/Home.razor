@page "/"
@using PoFastType.Shared.Models
@using PoFastType.Client.Services
@inject HttpClient Http
@inject IHttpClientFactory HttpClientFactory
@inject ILogger<Home> Logger
@inject IJSRuntime JSRuntime
@inject GameStateService GameStateService

<PageTitle>PoFastType - Home</PageTitle>

<div class="game-container page-content">
    <div class="row g-2">
        <!-- Left Pane: Text Display -->
        <div class="col-lg-6 col-12">
            <div class="card retro-card h-100">
                <div class="card-header retro-card-header">
                    <h5 class="mb-0">Text to Type</h5>
                </div>
                <div class="card-body">
                    @if (string.IsNullOrEmpty(sourceText))
                    {
                        <p class="text-muted">Click "Start New Game" to begin your typing test.</p>
                    }
                    else
                    {
                        <div class="text-display">
                            @RenderSourceTextWithHighlight()
                        </div>
                    }
                </div>
            </div>
        </div>

        <!-- Right Pane: Input Area -->
        <div class="col-lg-6 col-12">
            <div class="card retro-card h-100">
                <div class="card-header retro-card-header d-flex justify-content-between align-items-center flex-wrap">
                    <h5 class="mb-0">Your Input</h5>
                    @if (gameState == GameState.InProgress)
                    {
                        <div class="timer">
                            @remainingSeconds
                        </div>
                    }
                </div>
                <div class="card-body">
                    @if (gameState == GameState.PreGame)
                    {
                        <div class="text-center py-5">
                            <button class="btn btn-primary btn-lg glow-hover" @onclick="StartNewGame">
                                Start New Game
                            </button>
                        </div>                    }
                    else if (gameState == GameState.Loading)
                    {
                        <div class="text-center py-5">
                            <div class="spinner-border text-primary" role="status">
                                <span class="visually-hidden">Loading...</span>
                            </div>
                            <p class="mt-3">Generating your unique text with AI...</p>
                        </div>
                    }
                    else if (gameState == GameState.Countdown)
                    {
                        <div class="text-center py-5">
                            <div class="countdown">
                                @countdownNumber
                            </div>
                        </div>
                    }
                    else if (gameState == GameState.InProgress)
                    {
                        <textarea 
                            @ref="inputTextArea"
                            class="typing-input form-control" 
                            style="resize: none;"
                            @bind="userInput"
                            @bind:event="oninput"
                            @onkeydown="OnKeyDown"
                            @onkeyup="OnKeyUp"
                            disabled="@(gameState != GameState.InProgress)"
                            placeholder="Start typing here when the countdown finishes...">
                        </textarea>
                    }
                    else if (gameState == GameState.PostGame)
                    {
                        <div class="results-container">
                            <div class="typing-input" style="overflow-y: auto; white-space: pre-wrap;">
                                @RenderHighlightedText()
                            </div>
                        </div>
                    }
                </div>
            </div>
        </div>
    </div>    <!-- Results Card (shown after game) -->
    @if (gameState == GameState.PostGame)
    {
        <div class="row g-2 mt-1">
            <div class="col-12">
                <div class="card retro-card results-section">
                    <div class="card-header retro-card-header">
                        <h6 class="mb-0" style="font-size: 0.9rem;">Results</h6>
                    </div>                    <div class="card-body results-stats">
                        <!-- Main stats in 5 columns - adjusted for mobile and desktop -->
                        <div class="row g-1">
                            <div class="col-6 col-md">
                                <div class="stat-card">
                                    <div class="stat-label">Score</div>
                                    <div class="stat-value">@compositeScore.ToString("F0")</div>
                                </div>
                            </div>
                            <div class="col-4 col-md">
                                <div class="stat-card">
                                    <div class="stat-label">Accuracy</div>
                                    <div class="stat-value">@accuracy.ToString("F1")%</div>
                                </div>
                            </div>
                            <div class="col-4 col-md">
                                <div class="stat-card">
                                    <div class="stat-label">Gross WPM</div>
                                    <div class="stat-value">@grossWPM.ToString("F1")</div>
                                </div>
                            </div>
                            <div class="col-4 col-md">
                                <div class="stat-card">
                                    <div class="stat-label">Characters</div>
                                    <div class="stat-value">@correctCharacters/@totalCharacters</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    }
</div>

@code {    private string sourceText = string.Empty;
    private string userInput = string.Empty;
    private GameState gameState = GameState.PreGame;
    private int remainingSeconds = 5;
    private int countdownNumber = 3;
    private ElementReference inputTextArea;
    
    // Game tracking
    private DateTime gameStartTime;
    private string currentGameId = string.Empty;
    private int keystrokeSequence = 0;
    private DateTime lastKeystrokeTime;
    private List<KeystrokeData> gameKeystrokes = new();
    private List<DateTime> keystrokeTimes = new();
    private List<bool> keystrokeAccuracy = new();
    private List<KeystrokeError> keystrokeErrors = new();
    private int currentStreak = 0;
    private int longestStreak = 0;
    private Dictionary<string, Dictionary<string, int>> problemKeys = new();
    
    // Results
    private double netWPM = 0;
    private double accuracy = 0;
    private double grossWPM = 0;
    private double burstSpeed = 0;
    private double compositeScore = 0; // New composite scoring system
    private int correctCharacters = 0;
    private int totalCharacters = 0;
    private List<ProblemKey> topProblemKeys = new();

    private async Task StartNewGame()
    {
        Logger.LogInformation("StartNewGame: Method called.");
        gameState = GameState.Loading;
        StateHasChanged(); // Force UI update to show loading state
        userInput = string.Empty;
        ResetGameTracking();
        
        try
        {
            // Call the API to get new text
            var response = await Http.GetFromJsonAsync<TextResponse>("api/game/text");
            if (response?.text != null)
            {
                sourceText = response.text;
                await StartCountdown();
            }
            else
            {
                Logger.LogError("Failed to get text from API");
                gameState = GameState.PreGame;
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error getting text from API");
            gameState = GameState.PreGame;
        }
    }

    private async Task StartCountdown()
    {
        gameState = GameState.Countdown;
        
        for (int i = 3; i > 0; i--)
        {
            countdownNumber = i;
            StateHasChanged();
            await Task.Delay(1000);
        }
        
        await StartGame();
    }    private async Task StartGame()
    {
        gameState = GameState.InProgress;
        remainingSeconds = 5; // 5-second typing test
        gameStartTime = DateTime.UtcNow;
        currentGameId = Guid.NewGuid().ToString();
        keystrokeSequence = 0;
        lastKeystrokeTime = gameStartTime;
        gameKeystrokes.Clear();
        
        StateHasChanged(); // Force re-render to ensure textarea is in DOM
        
        // Focus the text area with retry logic
        await FocusInputWithRetry(inputTextArea, 10, 200); // Retry up to 10 times with 200ms delay
        
        // Start the timer
        _ = TimerTask();
    }

    private async Task FocusInputWithRetry(ElementReference element, int retries, int delayMs)
    {
        for (int i = 0; i < retries; i++)
        {
            try
            {
                if (element.Context is not null) // Check if ElementReference is valid
                {
                    // Check if the JavaScript function exists before invoking
                    var jsFunctionExists = await JSRuntime.InvokeAsync<bool>("eval", "typeof window.focusElement === 'function'");
                    
                    if (jsFunctionExists)
                    {
                        await JSRuntime.InvokeVoidAsync("focusElement", element);
                        Logger.LogInformation("Successfully focused input area after {Attempt} attempts.", i + 1);
                        return; // Exit if successful
                    }
                    else
                    {
                        Logger.LogWarning("window.focusElement not found on attempt {Attempt}.", i + 1);
                    }
                }
                else
                {
                    Logger.LogWarning("inputTextArea is not valid on attempt {Attempt}.", i + 1);
                }
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "Error focusing input area on attempt {Attempt}.", i + 1);
            }

            await Task.Delay(delayMs); // Wait before retrying
        }

        Logger.LogError("Failed to focus input area after {Retries} attempts.", retries);
    }

    private async Task TimerTask()
    {
        while (remainingSeconds > 0 && gameState == GameState.InProgress)
        {
            await Task.Delay(1000);
            remainingSeconds--;
            StateHasChanged();
        }
        
        if (gameState == GameState.InProgress)
        {
            await EndGame();
            StateHasChanged(); // Ensure UI updates immediately when game ends
        }
    }

    private async Task EndGame()
    {
        gameState = GameState.PostGame;
        CalculateResults();
        
        // Submit keystroke data to biometrics API
        await SubmitKeystrokeData();
        
        // Submit results to API if user is authenticated
        await SubmitResults();
    }    private async Task SubmitResults()
    {
        try
        {
            Logger.LogInformation("Submitting score as ANON");

            // Use anonymous HttpClient
            var anonymousHttpClient = HttpClientFactory.CreateClient("PoFastType.Api.Anonymous");
            // Create the game result object with ANON user
            var gameResult = new GameResult
            {
                NetWPM = netWPM,
                Accuracy = accuracy,
                GrossWPM = grossWPM,
                CompositeScore = compositeScore,
                ProblemKeysJson = System.Text.Json.JsonSerializer.Serialize(problemKeys),
                Timestamp = DateTime.UtcNow,
                Username = "ANON" // Explicitly set anonymous user name
            };

            // Submit the score using anonymous client
            var response = await anonymousHttpClient.PostAsJsonAsync("api/scores", gameResult);

            if (response.IsSuccessStatusCode)
            {
                Logger.LogInformation("Score submitted successfully (anonymous user)");
                // Notify other components that a new score was submitted
                GameStateService.NotifyScoreSubmitted();
            }
            else
            {
                Logger.LogWarning("Failed to submit score (anonymous): {StatusCode}", response.StatusCode);
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error submitting score");
        }
    }

    private void OnKeyDown(KeyboardEventArgs e)
    {
        if (gameState != GameState.InProgress) return;
        
        var now = DateTime.UtcNow;
        keystrokeTimes.Add(now);
        
        // Create keystroke data entry
        var currentPosition = userInput.Length;
        var expectedChar = currentPosition < sourceText.Length ? sourceText[currentPosition].ToString() : "";
        var isBackspace = e.Key == "Backspace";
        
        var keystroke = new KeystrokeData
        {
            PartitionKey = "TEMP", // Will be set properly in SubmitKeystrokeData
            GameId = currentGameId,
            SequenceNumber = keystrokeSequence++,
            Key = e.Key,
            ExpectedChar = expectedChar,
            IsBackspace = isBackspace,
            ElapsedMs = (long)(now - gameStartTime).TotalMilliseconds,
            IntervalMs = (long)(now - lastKeystrokeTime).TotalMilliseconds,
            TextPosition = currentPosition,
            CurrentWPM = CalculateCurrentWPM(now),
            CurrentAccuracy = CalculateCurrentAccuracy(),
            RecordedAt = now
        };
        
        lastKeystrokeTime = now;
        
        // Track problem keys
        var key = e.Key.ToLower();
        if (!problemKeys.ContainsKey(key))
        {
            problemKeys[key] = new Dictionary<string, int>();
        }
        
        // Will set IsCorrect in OnKeyUp after character is typed
        gameKeystrokes.Add(keystroke);
    }

    private void OnKeyUp(KeyboardEventArgs e)
    {
        if (gameState != GameState.InProgress) return;
        
        // Check accuracy for this keystroke
        var currentIndex = userInput.Length - 1;
        if (currentIndex >= 0 && currentIndex < sourceText.Length)
        {
            var expectedChar = sourceText[currentIndex];
            var actualChar = userInput[currentIndex];
            var isCorrect = expectedChar == actualChar;
            
            // Update the last keystroke entry with correctness
            if (gameKeystrokes.Any())
            {
                var lastKeystroke = gameKeystrokes.Last();
                lastKeystroke.IsCorrect = isCorrect;
            }
            
            keystrokeAccuracy.Add(isCorrect);
            
            if (isCorrect)
            {
                currentStreak++;
                longestStreak = Math.Max(longestStreak, currentStreak);
            }
            else
            {
                // Track the error
                var error = new KeystrokeError
                {
                    IntendedKey = expectedChar.ToString(),
                    ActualKey = actualChar.ToString(),
                    Position = currentIndex
                };
                keystrokeErrors.Add(error);
                
                // Update problem keys
                var intendedKey = expectedChar.ToString().ToLower();
                var actualKey = actualChar.ToString().ToLower();
                
                if (!problemKeys.ContainsKey(intendedKey))
                {
                    problemKeys[intendedKey] = new Dictionary<string, int>();
                }
                
                if (!problemKeys[intendedKey].ContainsKey(actualKey))
                {
                    problemKeys[intendedKey][actualKey] = 0;
                }
                
                problemKeys[intendedKey][actualKey]++;
                
                currentStreak = 0;
            }
        }
    }
    
    private double CalculateCurrentWPM(DateTime now)
    {
        var elapsed = (now - gameStartTime).TotalMinutes;
        if (elapsed <= 0) return 0;
        
        var wordsTyped = userInput.Split(' ', StringSplitOptions.RemoveEmptyEntries).Length;
        return wordsTyped / elapsed;
    }
    
    private double CalculateCurrentAccuracy()
    {
        if (userInput.Length == 0) return 100;
        
        var correct = 0;
        var minLength = Math.Min(sourceText.Length, userInput.Length);
        
        for (int i = 0; i < minLength; i++)
        {
            if (sourceText[i] == userInput[i])
                correct++;
        }
        
        return (double)correct / userInput.Length * 100;
    }
    
    private async Task SubmitKeystrokeData()
    {
        try
        {
            // Get actual user ID
            var userId = await JSRuntime.InvokeAsync<string>("localStorage.getItem", "userId");
            if (string.IsNullOrEmpty(userId))
            {
                userId = Guid.NewGuid().ToString();
                await JSRuntime.InvokeVoidAsync("localStorage.setItem", "userId", userId);
            }
            
            // Update all keystroke entries with correct user ID
            foreach (var keystroke in gameKeystrokes)
            {
                keystroke.PartitionKey = userId;
            }
            
            // Submit in batch for efficiency
            if (gameKeystrokes.Any())
            {
                var response = await Http.PostAsJsonAsync("/api/biometrics/keystrokes/batch", gameKeystrokes);
                
                if (response.IsSuccessStatusCode)
                {
                    Logger.LogInformation("Successfully submitted {Count} keystrokes for game {GameId}", 
                        gameKeystrokes.Count, currentGameId);
                }
                else
                {
                    Logger.LogWarning("Failed to submit keystroke data: {StatusCode}", response.StatusCode);
                }
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error submitting keystroke data");
            // Don't fail the game submission if biometrics submission fails
        }
    }

    private void CalculateResults()
    {
        var gameEndTime = DateTime.UtcNow;
        var gameDuration = gameEndTime - gameStartTime;
        var timeInMinutes = gameDuration.TotalMinutes;
        
        totalCharacters = userInput.Length; // Total characters typed by user
        correctCharacters = CalculateCorrectCharacters(sourceText, userInput);
        
        // Calculate WPM (words are typically 5 characters)
        var wordsTyped = userInput.Split(' ', StringSplitOptions.RemoveEmptyEntries).Length;
        grossWPM = wordsTyped / timeInMinutes;
        
        // Calculate accuracy based on characters actually typed
        accuracy = totalCharacters > 0 ? (double)correctCharacters / totalCharacters * 100 : 0;
        netWPM = grossWPM * (accuracy / 100);
        
        // Calculate burst speed (peak WPM in any 10-second window)
        burstSpeed = CalculateBurstSpeed();
        
        // Calculate longest streak
        longestStreak = CalculateLongestStreak();
        
        // Calculate composite score
        compositeScore = CalculateCompositeScore();
        
        // Calculate top problem keys
        topProblemKeys = CalculateTopProblemKeys();
    }

    private int CalculateCorrectCharacters(string source, string input)
    {
        int correct = 0;
        int minLength = Math.Min(source.Length, input.Length);
        
        for (int i = 0; i < minLength; i++)
        {
            if (source[i] == input[i])
            {
                correct++;
            }
        }
        
        return correct;
    }

    private double CalculateCompositeScore()
    {
        // Log values for debugging
        Logger.LogInformation("Calculating composite score: accuracy={Accuracy}, netWPM={NetWPM}, totalCharacters={TotalCharacters}, longestStreak={LongestStreak}", 
            accuracy, netWPM, totalCharacters, longestStreak);
        
        // Composite scoring formula that balances multiple factors:
        // 
        // Base Score Components:
        // 1. Speed Component (40%): Net WPM * 10 (primary speed measure)
        // 2. Accuracy Bonus (25%): Accuracy^1.5 (exponential reward for high accuracy)
        // 3. Consistency Bonus (20%): (Longest Streak / Total Characters) * 100 * 5
        // 4. Peak Performance (10%): (Burst Speed / 10) (rewards peak performance)
        // 5. Completion Bonus (5%): (Characters Typed / Total Characters) * 50
        //
        // Formula Design:
        // - Rewards both speed and accuracy
        // - Heavily penalizes low accuracy to prevent "speed only" strategies
        // - Rewards consistency (long streaks of correct typing)
        // - Provides bonus for peak performance bursts
        // - Gives small bonus for completion percentage
        
        if (accuracy <= 0 || netWPM <= 0) 
        {
            Logger.LogWarning("Composite score returning 0 due to accuracy={Accuracy} or netWPM={NetWPM}", accuracy, netWPM);
            return 0;
        }
        
        // 1. Speed Component (40% weight) - Base score from Net WPM
        double speedComponent = netWPM * 10;
        
        // 2. Accuracy Bonus (25% weight) - Exponential accuracy reward
        double accuracyBonus = Math.Pow(accuracy, 1.5);
        
        // 3. Consistency Bonus (20% weight) - Reward for long streaks
        double consistencyRatio = totalCharacters > 0 ? (double)longestStreak / totalCharacters : 0;
        double consistencyBonus = consistencyRatio * 100 * 5;
        
        // 4. Peak Performance Bonus (10% weight) - Burst speed component
        double peakBonus = burstSpeed / 10;
        
        // 5. Completion Bonus (5% weight) - Typing completion percentage
        double completionRatio = totalCharacters > 0 ? (double)userInput.Length / totalCharacters : 0;
        double completionBonus = Math.Min(completionRatio, 1.0) * 50; // Cap at 100% completion
        
        // Calculate weighted composite score
        double compositeScore = (speedComponent * 0.4) + 
                               (accuracyBonus * 0.25) + 
                               (consistencyBonus * 0.2) + 
                               (peakBonus * 0.1) + 
                               (completionBonus * 0.05);
        
        // Apply accuracy multiplier to prevent low-accuracy speed gaming
        double accuracyMultiplier = Math.Max(0.1, accuracy / 100); // Minimum 10% score retention
        
        var finalScore = Math.Max(0, compositeScore * accuracyMultiplier);
        Logger.LogInformation("Final composite score: {FinalScore} (before multiplier: {CompositeScore}, multiplier: {AccuracyMultiplier})", 
            finalScore, compositeScore, accuracyMultiplier);
        
        return finalScore;
    }

    private double CalculateBurstSpeed()
    {
        if (keystrokeTimes.Count < 2) return 0;
        
        var maxWPM = 0.0;
        var windowSize = TimeSpan.FromSeconds(10);
        
        for (int i = 0; i < keystrokeTimes.Count; i++)
        {
            var windowStart = keystrokeTimes[i];
            var windowEnd = windowStart + windowSize;
            
            var keystrokesInWindow = keystrokeTimes.Count(t => t >= windowStart && t <= windowEnd);
            var wordsInWindow = keystrokesInWindow / 5.0; // Approximate words per keystroke
            var wpmInWindow = wordsInWindow / (windowSize.TotalMinutes);
            
            maxWPM = Math.Max(maxWPM, wpmInWindow);
        }
        
        return maxWPM;
    }

    private int CalculateLongestStreak()
    {
        var maxStreak = 0;
        var currentStreak = 0;
        
        foreach (var isCorrect in keystrokeAccuracy)
        {
            if (isCorrect)
            {
                currentStreak++;
                maxStreak = Math.Max(maxStreak, currentStreak);
            }
            else
            {
                currentStreak = 0;
            }
        }
        
        return maxStreak;
    }

    private List<ProblemKey> CalculateTopProblemKeys()
    {
        var problemKeyList = new List<ProblemKey>();
        
        foreach (var intendedKey in problemKeys)
        {
            foreach (var actualKey in intendedKey.Value)
            {
                problemKeyList.Add(new ProblemKey
                {
                    IntendedKey = intendedKey.Key,
                    ActualKey = actualKey.Key,
                    Frequency = actualKey.Value
                });
            }
        }
        
        return problemKeyList
            .OrderByDescending(pk => pk.Frequency)
            .Take(5)
            .ToList();
    }

    private RenderFragment RenderSourceTextWithHighlight()
    {
        return builder =>
        {
            if (gameState != GameState.InProgress || string.IsNullOrEmpty(userInput))
            {
                builder.AddContent(0, sourceText);
                return;
            }

            var minLength = Math.Min(sourceText.Length, userInput.Length);
            
            // Render characters that have been typed
            for (int i = 0; i < minLength; i++)
            {
                bool isCorrect = sourceText[i] == userInput[i];
                
                builder.OpenElement(i * 2, "span");
                if (isCorrect)
                {
                    builder.AddAttribute(i * 2 + 1, "style", "color: #00ff41; text-shadow: 0 0 5px #00ff41;");
                }
                else
                {
                    builder.AddAttribute(i * 2 + 1, "style", "color: #ff3333; text-decoration: underline; text-decoration-color: #ff3333; background-color: rgba(255, 51, 51, 0.2);");
                }
                builder.AddContent(i * 2 + 2, sourceText[i]);
                builder.CloseElement();
            }
            
            // Render current character to type (with cursor effect)
            if (minLength < sourceText.Length)
            {
                builder.OpenElement(minLength * 2, "span");
                builder.AddAttribute(minLength * 2 + 1, "style", "background-color: rgba(255, 140, 0, 0.4); color: #ff8c00; font-weight: bold; animation: pulse 1s infinite;");
                builder.AddContent(minLength * 2 + 2, sourceText[minLength]);
                builder.CloseElement();
                
                // Render remaining characters
                if (minLength + 1 < sourceText.Length)
                {
                    builder.AddContent((minLength + 1) * 2, sourceText.Substring(minLength + 1));
                }
            }
        };
    }

    private RenderFragment RenderHighlightedText()
    {
        return builder =>
        {
            var minLength = Math.Min(sourceText.Length, userInput.Length);
            
            for (int i = 0; i < minLength; i++)
            {
                if (sourceText[i] == userInput[i])
                {
                    builder.AddContent(i, userInput[i]);
                }
                else
                {
                    builder.OpenElement(i, "span");
                    builder.AddAttribute(i, "style", "background-color: #ffebee; color: #c62828; text-decoration: underline;");
                    builder.AddContent(i, userInput[i]);
                    builder.CloseElement();
                }
            }
            
            // Add any extra characters typed
            for (int i = minLength; i < userInput.Length; i++)
            {
                builder.OpenElement(i, "span");
                builder.AddAttribute(i, "style", "background-color: #ffebee; color: #c62828; text-decoration: underline;");
                builder.AddContent(i, userInput[i]);
                builder.CloseElement();
            }
        };
    }    private void ResetGame()
    {
        gameState = GameState.PreGame;
        sourceText = string.Empty;
        userInput = string.Empty;
        remainingSeconds = 5; // Reset to 5 seconds for next game
        countdownNumber = 3;
        ResetGameTracking();
    }

    private void ResetGameTracking()
    {
        keystrokeTimes.Clear();
        keystrokeAccuracy.Clear();
        keystrokeErrors.Clear();
        gameKeystrokes.Clear();
        keystrokeSequence = 0;
        currentStreak = 0;
        longestStreak = 0;
        problemKeys.Clear();
        topProblemKeys.Clear();
        netWPM = 0;
        accuracy = 0;
        grossWPM = 0;
        burstSpeed = 0;
        compositeScore = 0;
        correctCharacters = 0;
        totalCharacters = 0;
    }

    public enum GameState
    {
        PreGame,
        Loading,
        Countdown,
        InProgress,
        PostGame
    }
}
